[[preliminary]]
== 为什么需要在运行时生成代码？

Java 语言带有一套比较严格的类型系统。Java 要求所有变量和对象都有一个确定的类型，并且任何向不兼容类型赋值都会造成一个错误。这些错误通常都会被编译器检查出来，极少情况下会被 Java 运行时检查到，然后抛一个非法类型的错误。如此严格的类型在大多数情况下是比较令人满意的，比如在编写业务应用时。通常，可以以任何模型元素表示其自己的类型这种明确的方式来描述业务域。通过这种方式，我们可以用 Java 构建具有非常强可读性和稳定性的应用，应用中的错误也非常贴近源码。除此之外，Java 严格的类型系统造就 Java 在企业编程中的普及。

_然而，通过强制其严格的类型系统，Java 强加一些限制，在其他领域限制了语言应用范围。_ 比如，当写一个通用的库时，这个库将被其他 Java 应用使用，我们通常不能引用任何在用户应用中定义的类型，因为当这个库被编译时，我们还不知道这些类型。为了调用用户为知代码的方法或者访问其属性，Java 类库提供了一套反射 API。使用这套反射 API，我们就可以反省为知类型，进而调用方法或者访问属性。不幸的是，这套反射 API 的用法有两个明显的缺点：

* 相比硬编码的方法调用，使用 http://docs.oracle.com/javase/tutorial/reflect/index.html[反射 API 非常慢]：首先，需要执行一个相当昂贵的方法查找来获取描述特定方法的对象。同时，当一个方法被调用时，这要求 Java 虚拟机去运行本地代码，相比直接调用，这需要一个很长的运行时间。然而，现代 Java 虚拟机知道一个被称为“类型膨胀”的概念：基于 JNI 的方法调用会被动态生成的字节码给替换掉，而这些方法调用的字节码被注入到一个动态生成的类中。（即使 Java 虚拟机自身也使用代码生成！）毕竟，Java 的类型膨胀系统仍存在生成非常一般的代码的缺点，例如，仅能使用基本类型的装箱类型以至于性能缺陷不能完全解决。
* 反射 API 能绕过类型安全检查：即使 Java 虚拟机支持通过反射进行代码调用，但反射 API 自身并不是类型安全的。当编写一个类库时，只要我们不需要把反射 API 暴露给库的用户，就不会有什么大问题。毕竟，当我们编译类库时，我们不知道用户代码，而且也不能校验我们的库与用户类型是否匹配。

[[writing-a-security-library]]
=== 编写一个安全的库

[source,{java_source_attr}]
----
class Service {
  void deleteEverything() {
    // delete everything ...
  }
}
----


[source,{java_source_attr}]
----
@Retention(RetentionPolicy.RUNTIME)
@interface Secured {
  String user();
}

class UserHolder {
  static String user;
}

interface Framework {
  <T> T secure(Class<T> type);
}
----


[source,{java_source_attr}]
----
class SecuredService extends Service {
  @Override
  void deleteEverything() {
    if(UserHolder.user.equals("ADMIN")) {
      super.deleteEverything();
    } else {
      throw new IllegalStateException("Not authorized");
    }
  }
}
----

[source,{java_source_attr}]
----
class HardcodedFrameworkImpl implements Framework {
  @Override
  public <T> T secure(Class<T> type) {
    if(type == Service.class) {
      return (T) new SecuredService();
    } else {
      throw new IllegalArgumentException("Unknown: " + type);
    }
  }
}
----

[[general-information]]
=== 基本信息
