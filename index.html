<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <!--[if IE]><meta content="IE=edge" http-equiv="X-UA-Compatible"><![endif]--> <meta content="width=device-width,initial-scale=1" name="viewport"> <meta content="Asciidoctor 1.5.6.1" name="generator"> <meta content="Byte Buddy 教程 -- Byte Buddy 是一个字节码生成与维护的库，主要用于在 Java 应用运行时生成和修改 Java 类，并且不需要编译器来辅助。" name="description"> <meta content="Byte Buddy Tutorial, Byte Buddy 教程, 字节码, Java, JVM, Java Virtual Machine, Java 虚拟机" name="keywords"> <meta content="D瓜哥" name="author"> <title>Byte Buddy 教程 Alpha</title> <link href="//fonts.proxy.ustclug.org/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700" rel="stylesheet"> <link href="./target/styles/asciidoctor.css" rel="stylesheet"> <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"> <link href="./target/styles/coderay-asciidoctor.css" rel="stylesheet"> </head> <body class="toc2 book toc-left"> <div id="header"> <h1>Byte Buddy 教程 <sup>Alpha</sup></h1> <div class="details"> <span class="author" id="author">D瓜哥</span><br> <span class="email" id="email"><a href="http://www.diguage.com/" class="bare">http://www.diguage.com/</a></span><br> <span id="revnumber">v 0.1.0,</span> <span id="revdate">2017-07-24</span> </div> <div class="toc2" id="toc"> <div id="toctitle">目录</div> <ul class="sectlevel1"> <li><a href="#_前言">前言</a> <ul class="sectlevel2"> <li><a href="#_友情支持">友情支持</a></li> <li><a href="#_官网及版本库">官网及版本库</a></li> </ul> </li> <li><a href="#preliminary">为什么需要在运行时生成代码？</a> <ul class="sectlevel2"> <li><a href="#writing-a-security-library">编写一个安全的库</a></li> <li><a href="#general-information">基本信息</a></li> </ul> </li> <li><a href="#creating-a-class">创建一个类</a> <ul class="sectlevel2"> <li><a href="#domain-specific-language-and-immutability">领域特定语言和不变性</a></li> <li><a href="#redefining-and-rebasing-existing-classes">重新定义或者重定基底已经存在的类</a></li> <li><a href="#loading-a-class">加载类</a></li> <li><a href="#reloading-a-class">重新加载类</a></li> <li><a href="#working-with-unloaded-classes">操作没有加载的类</a></li> <li><a href="#creating-java-agents">创建 Java Agents</a></li> <li><a href="#loading-classes-in-android-applications">在 Android 应用中加载类</a></li> <li><a href="#working-with-generic-types">使用泛型类</a></li> </ul> </li> <li><a href="#fields-and-methods">属性和方法</a> <ul class="sectlevel2"> <li><a href="#a-closer-look-at-fixed-values">深入细看一个固定值</a></li> <li><a href="#delegating-a-method-call">委托方法调用</a></li> <li><a href="#calling-a-super-method">调用超类方法</a></li> <li><a href="#calling-a-default-method">调用默认方法</a></li> <li><a href="#calling-a-specific-method">调用特定方法</a></li> <li><a href="#accessing-fields">访问属性</a></li> <li><a href="#miscellaneous">杂项</a></li> </ul> </li> <li><a href="#annotations">注解</a> <ul class="sectlevel2"> <li><a href="#type-annotations">类型注解</a></li> <li><a href="#attribute-appenders">属性附加器</a></li> </ul> </li> <li><a href="#custom-instrumentation">定制化仪表</a> <ul class="sectlevel2"> <li><a href="#creating-a-custom-assigner">创建自定义分配器</a></li> <li><a href="#creating-a-custom-parameter-binder">创建自定义参数绑定器</a></li> </ul> </li> <li><a href="#license">附录 A: 版权声明</a></li> </ul> </div> </div> <div id="content"> <div id="preamble"> <div class="sectionbody"> <script> var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae7f1fd4c53f019313f5a1db9b0d4803";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})(); </script> </div> </div> <div class="sect1"> <h2 id="_前言">前言</h2> <div class="sectionbody"> <div class="paragraph"> <p><strong>本文档是 D瓜哥 在学习 <a href="http://bytebuddy.net/#/tutorial">Byte Buddy Tutorial</a> 时随手翻译的。水平有限，难免失误，欢迎随时发生 PR。谢谢！</strong></p> </div> <div class="sect2"> <h3 id="_友情支持">友情支持</h3> <div class="paragraph"> <p>如果您觉得这个笔记对您有所帮助，看在 D瓜哥 码字的辛苦上，请友情支持一下。屌丝逆袭，赢取白富美，走向人生巅峰就靠这个了，😜 😜</p> </div> <table class="tableblock frame-none grid-all spread"> <colgroup> <col style="width: 50%"> <col style="width: 50%"> </colgroup> <tbody> <tr> <td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img alt="支付宝" src="./target/images/images/alipay.jpeg" title="支付宝" width="50%"></span></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img alt="微信" src="./target/images/images/wxpay.png" title="微信" width="55%"></span></td> </tr> </tbody> </table> </div> <div class="sect2"> <h3 id="_官网及版本库">官网及版本库</h3> <div class="paragraph"> <p>本文档的版本库使用 Git 管理。另外，单独发布阅读版。</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">“地瓜哥”博客网</dt> <dd> <p><a href="http://www.diguage.com/" class="bare">http://www.diguage.com/</a> 。D瓜哥的个人博客。欢迎光临，不过，内容很杂乱，请见谅。不见谅，你来打我啊，😂😂</p> </dd> <dt class="hdlist1">本文档官网</dt> <dd> <p><a href="http://notes.diguage.com/byte-buddy-tutorial/" class="bare">http://notes.diguage.com/byte-buddy-tutorial/</a> 。为了方便阅读，这里展示了处理好的文档。阅读请点击这个网址。</p> </dd> <dt class="hdlist1">本文档版本库</dt> <dd> <p><a href="https://github.com/diguage/byte-buddy-tutorial" class="bare">https://github.com/diguage/byte-buddy-tutorial</a> 。反正也没啥保密可言，版本库分分钟给出。😜</p> </dd> </dl> </div> </div> </div> </div> <div class="sect1"> <h2 id="preliminary">为什么需要在运行时生成代码？</h2> <div class="sectionbody"> <div class="paragraph"> <p>Java 语言带有一套比较严格的类型系统。Java 要求所有变量和对象都有一个确定的类型，并且任何向不兼容类型赋值都会造成一个错误。这些错误通常都会被编译器检查出来，极少情况下会被 Java 运行时检查到，然后抛一个非法类型的错误。如此严格的类型在大多数情况下是比较令人满意的，比如在编写业务应用时。通常，可以以任何模型元素表示其自己的类型这种明确的方式来描述业务域。通过这种方式，我们可以用 Java 构建具有非常强可读性和稳定性的应用，应用中的错误也非常贴近源码。除此之外，Java 严格的类型系统造就 Java 在企业编程中的普及。</p> </div> <div class="paragraph"> <p><em>然而，通过强制其严格的类型系统，Java 强加一些限制，在其他领域限制了语言应用范围。</em> 比如，当写一个通用的库时，这个库将被其他 Java 应用使用，我们通常不能引用任何在用户应用中定义的类型，因为当这个库被编译时，我们还不知道这些类型。为了调用用户为知代码的方法或者访问其属性，Java 类库提供了一套反射 API。使用这套反射 API，我们就可以反省为知类型，进而调用方法或者访问属性。不幸的是，这套反射 API 的用法有两个明显的缺点：</p> </div> <div class="ulist"> <ul> <li> <p>相比硬编码的方法调用，使用 <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">反射 API 非常慢</a>：首先，需要执行一个相当昂贵的方法查找来获取描述特定方法的对象。同时，当一个方法被调用时，这要求 Java 虚拟机去运行本地代码，相比直接调用，这需要一个很长的运行时间。然而，现代 Java 虚拟机知道一个被称为“类型膨胀”的概念：基于 JNI 的方法调用会被动态生成的字节码给替换掉，而这些方法调用的字节码被注入到一个动态生成的类中。（即使 Java 虚拟机自身也使用代码生成！）毕竟，Java 的类型膨胀系统仍存在生成非常一般的代码的缺点，例如，仅能使用基本类型的装箱类型以至于性能缺陷不能完全解决。</p> </li> <li> <p>反射 API 能绕过类型安全检查：即使 Java 虚拟机支持通过反射进行代码调用，但反射 API 自身并不是类型安全的。当编写一个类库时，只要我们不需要把反射 API 暴露给库的用户，就不会有什么大问题。毕竟，当我们编译类库时，我们不知道用户代码，而且也不能校验我们的库与用户类型是否匹配。<em>有时，需要通过让一个库为我们自己调用我们自己的方法之一来向用户显示反射 API 示例。</em>这是使用反射 API 变得有问题的地方，因为 Java 编译器将具有所有信息来验证我们的程序的类型安全性。例如，当实现方法级安全库时，这个库的用户将希望这个库做到强制执行安全限制才能调用方法。为此，在用户传递过来方法所需的参数后，这个库将反射性地调用方法。这样，就没有编译时类型检查这些方法参数是否与方法的反射调用相匹配。方法调用依然会校验，只是被推迟到了运行时。这样做，我们就错失了 Java 编程语言的一大特性。</p> </li> </ul> </div> <div class="paragraph"> <p>这正是运行时代码生成能帮助我们的地方。它允许我们模拟一些只有使用动态编程语言编程才有的特性，而且不丢失 Java 的静态类型检查。这样，我们就可以两全其美并且还可以提高运行时性能。为了更好地理解这个问题，让我们实现一个方法级安全库。</p> </div> <div class="sect2"> <h3 id="writing-a-security-library">编写一个安全的库</h3> <div class="paragraph"> <p>业务应用程序可能会增长，有时很难在我们的应用程序中概述调用堆栈。当我们在应用程序中使用至关重要的方法时，而这些方法只能在特定条件下调用，这可能会变得有问题。 设想一下，实现重置功能的业务应用程序可以从应用程序的数据库中删除所有内容。</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Service</span> {
  <span class="type">void</span> deleteEverything() {
    <span class="comment">// delete everything ...</span>
  }
}</code></pre> </div> </div> <div class="paragraph"> <p>这样的复位操作当然只能由管理员执行，而不是由应用程序的普通用户执行。通过分析源代码，我们当然可以确保这将永远不会发生。但是，我们期望我们的应用能够在未来发展壮大。因此，我们希望实现更紧密的安全模型，其中通过对应用程序的当前用户的显式检查来保护方法调用。我们通常会使用一个安全框架来确保该方法从不被除管理员外的任何人调用。</p> </div> <div class="paragraph"> <p>为此，假设我们使用具有公共 API 如下的安全框架：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@interface</span> Secured {
  <span class="predefined-type">String</span> user();
}

<span class="type">class</span> <span class="class">UserHolder</span> {
  <span class="directive">static</span> <span class="predefined-type">String</span> user;
}

<span class="type">interface</span> <span class="class">Framework</span> {
  &lt;T&gt; T secure(<span class="predefined-type">Class</span>&lt;T&gt; type);
}</code></pre> </div> </div> <div class="paragraph"> <p>在此框架中，<code>Secured</code> 注解应用于标记只能由给定用户访问的方法。<code>UserHolder</code> 用于在全局范围内定义当前登录到应用程序的用户。<code>Framework</code> 接口允许通过调用给定类型的默认构造函数来创建安全实例。当然，这个框架过于简单，但是，从本质上来说，即使流行的安全框架，例如 <a href="http://projects.spring.io/spring-security/">Spring Security</a>，也是这样实现的。这个安全框架的一个特点是我们过滤用户的类型。通过调用我们框架的接口，我们承诺返回给用户任何类型 <code>T</code> 的实例。幸亏这样，用户能够透明地他自己的类型进行交互，就像安全框架根本不存在一样。在测试环境中，用户甚至可以创建其类型的不安全实例，使用这些实例来代替安全实例。你会同意这真的很方便！已知这种框架使用 POJO，普通的旧 Java 对象进行交互，这是一种用于描述不侵入框架的术语，这些框架不会将自己的类型强加给用户。</p> </div> <div class="paragraph"> <p>现在，想象一下，假如我们知道传递给 <code>Framework</code> 的类型只能是 <code>T = Service</code>，而且 <code>deleteEverything</code> 方法用 <code>@Secured("ADMIN")</code> 注解。这样，我们可以通过简单的子类化来轻松实现这种特定类型的安全版本：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">SecuredService</span> <span class="directive">extends</span> Service {
  <span class="annotation">@Override</span>
  <span class="type">void</span> deleteEverything() {
    <span class="keyword">if</span>(UserHolder.user.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">ADMIN</span><span class="delimiter">&quot;</span></span>)) {
      <span class="local-variable">super</span>.deleteEverything();
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not authorized</span><span class="delimiter">&quot;</span></span>);
    }
  }
}</code></pre> </div> </div> <div class="paragraph"> <p>通过这个额外的类，我们可以实现框架如下：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">HardcodedFrameworkImpl</span> <span class="directive">implements</span> Framework {
  <span class="annotation">@Override</span>
  <span class="directive">public</span> &lt;T&gt; T secure(<span class="predefined-type">Class</span>&lt;T&gt; type) {
    <span class="keyword">if</span>(type == Service.class) {
      <span class="keyword">return</span> (T) <span class="keyword">new</span> SecuredService();
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown: </span><span class="delimiter">&quot;</span></span> + type);
    }
  }
}</code></pre> </div> </div> <div class="paragraph"> <p>当然这个实现并没有太多的用处。通过标注 <code>secure</code> 方法签名，我们建议该方法可以为任何类型提供安全性，但实际上，一旦遇到其他事情，我们将抛出一个异常，然后是已知的 <code>Service</code>。此外，当编译库时，这将需要我们的安全库知道有关此特定 <code>Service</code> 类型的信息。显然，这不是实现框架的可行解决方案。那么我们如何解决这个问题呢？好吧，由于这是一个关于代码生成库的教程，您可能已经猜到答案：当通过调用 <code>secure</code> 方法， <code>Service</code> 类第一次被我们安全框架知道时，我们会在运行时后台地创建一个子类。通过使用代码生成，我们可以使用任何给定的类型，在运行时将其子类化，并覆盖我们要保护的方法。在我们的例子中，我们覆盖所有被 <code>@Secured</code> 注解标注的方法，并从注解的 <code>user</code> 属性中读取所需的用户。许多流行的 Java 框架都使用类似的方法实现。</p> </div> </div> <div class="sect2"> <h3 id="general-information">基本信息</h3> <div class="paragraph"> <p>在学习代码生成和 Byte Buddy 之前，请注意，应该谨慎使用代码生成。Java 类型对于 Java 虚拟机来说，是相当特别的东西，通常不能当做垃圾被回收。因此，不应该过度使用代码生成，而应该只在生成代码是解决问题的唯一出路时使用。但是，如果需要像上面的示例那样增强未知类型时，则代码生成很可能是您唯一的选择。用于安全性，事务管理，对象关系映射或类型模拟（mock）等框架是代码生成库的典型用户。</p> </div> <div class="paragraph"> <p>当然，Byte Buddy 不是 Java 虚拟机上第一个代码生成库。不过，我们认为 Byte Buddy 拥有其他框架没有的技巧。Byte Buddy 的总体目标是通过专注于其领域特定语言和注解的使用来声明式地进行工作。据我们所知，没有其他针对 Java 虚拟机的代码生成库以这种方式工作。不过，你可能希望看一下其他代码生成框架，以找出最适合您的套件。以下库在 Java 中很流行：</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html"><strong>Java Proxy</strong></a></dt> <dd> <p>Java 类库自带了一个代理工具，它允许为实现了一系列接口的类创建代理。这个内置的代理供应商非常方便，但局限性也特别明显。 上面提到的安全框架就不能用这样的方式来实现的，因为我们想扩展是类而不是扩展接口。</p> </dd> <dt class="hdlist1"><a href="https://github.com/cglib/cglib"><strong>cglib</strong></a></dt> <dd> <p>代码生成库（注：这里指 <code>cglib</code>）诞生于 Java 初期，但不幸的是没有跟上 Java 平台的发展。然而，cglib 仍然是一个相当强大的库，但其积极的开发却变得相当模糊。鉴于此，其许多用户已经离开了 cglib。</p> </dd> <dt class="hdlist1"><a href="https://github.com/jboss-javassist/javassist"><strong>Javassist</strong></a></dt> <dd> <p>该库附带一个编译器，它使用包含 Java 源代码的字符串，这些字符串在应用程序的运行时被转换为 Java 字节码。这是非常有前途的，本质上是一个好主意，因为 Java 源代码显然是描述 Java 类的好方法。但是，Javassist 编译器在功能上比不了 javac 编译器，并且在动态组合字符串以实现比较复杂的逻辑时容易出错。此外，Javassist 还提供了一个类似于 Java 类库中的代理工具，但允许扩展类，并不限于接口。然而，Javassist 的代理工具的范围在其 API 和功能上仍然受到限制。</p> </dd> </dl> </div> </div> </div> </div> <div class="sect1"> <h2 id="creating-a-class">创建一个类</h2> <div class="sectionbody"> <div class="paragraph"> <p>任何一个由 Byte Buddy 创建的类型都是通过 <code>ByteBuddy</code> 类的实例来完成的。通过简单地调用 <code>new ByteBuddy()</code> 就可以创建一个新实例，然后就可以出发了。希望你使用一个集成开发环境，这样在调用一个给定实例的方法时就能得到相应的提示。这样，你的集成开发环境就会引导你完成相应的方法调用，防止手动在 Byte Buddy 文档中查阅某个类的 API。正如之前所说，Byte Buddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性。集成开发环境的提示在大部分情况下会指引你到正确的方向。说的够多了，让我们在 Java 编程环境中创建第一个类吧：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">DynamicType.Unloaded&lt;?&gt; dynamicType = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .make();</code></pre> </div> </div> <div class="paragraph"> <p>正如前面所设想的，上面的示例代码会创建一个继承至 <code>Object</code> 类型的类。这个动态创建的类型与直接扩展 <code>Object</code> 并且没有实现任何方法、属性和构造函数的类型是等价的。你可能已经注意到，我们都没有命名动态生成的类型，通常在定义 Java 类时却是必须的。当然，你也可以很容易地明确地命名这个类型：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">DynamicType.Unloaded&lt;?&gt; dynamicType = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .name(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Type</span><span class="delimiter">&quot;</span></span>)
  .make();</code></pre> </div> </div> <div class="paragraph"> <p>如果没有明确的命名会怎么样呢？Byte Buddy 与 <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">约定大于配置</a> 息息相关，为你提供了我们认为比较方面的默认配置。至于类型命名，Byte Buddy 的默认配置提供了 <code>NamingStrategy</code>，它基于动态类型的超类名称来随机生成类名。此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 <code>example.Foo</code>，那么生成的名称将会类似于 <code>example.FooByteBuddy1376491271</code>，这里的数字序列是随机的。这个规则的例外情况就是当子类是从 <code>java.lang</code> 包下的类扩展时，就是 <code>Object</code> 所在的包。Java 的安全模型不允许自定义类型存放在这个命名空间下。因此，默认命名策略下，这些类型名称将会冠以 <code>net.bytebuddy.renamed</code> 的前缀。</p> </div> <div class="paragraph"> <p>默认行为也许对你来说并不方便。感谢约定大于配置原则，你总是可以根据你的需要来选择默认行为。这正是 <code>ByteBuddy</code> 的优越之处。通过 <code>new ByteBuddy()</code> 创建实例，你就创建了整套的默认配置。通过调用在这个配置上的方法，你就可以根据你的需要来订制它。让我们试试：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">DynamicType.Unloaded&lt;?&gt; dynamicType = <span class="keyword">new</span> ByteBuddy()
  .with(<span class="keyword">new</span> NamingStrategy.AbstractBase() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> subclass(TypeDescription superClass) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">i.love.ByteBuddy.</span><span class="delimiter">&quot;</span></span> + superClass.getSimpleName();
    }
  })
  .subclass(<span class="predefined-type">Object</span>.class)
  .make();</code></pre> </div> </div> <div class="paragraph"> <p>在上面这里例子中，我们创建了一个新的配置，在类型命名方面，不同于默认配置。匿名类被简单实现为连接 <code>i.love.ByteBuddy</code> 和基类的简要名称。当扩展 <code>Object</code> 类型时，动态类将被命名为 <code>i.love.ByteBuddy.Object</code>。当创建自己的命名策略时，需要特别小心。Java 虚拟机就是使用名字来区分不同的类型的，这正是为什么要避免命名冲突的原因。如果你需要定制命名行为，请考虑使用 Byte Buddy 内置的 <code>NamingStrategy.SuffixingRandom</code>，你可以通过引入比默认对你应用更有意义的前缀来定制命名行为。</p> </div> <div class="sect2"> <h3 id="domain-specific-language-and-immutability">领域特定语言和不变性</h3> <div class="paragraph"> <p>在看过 Byte Buddy 这种领域特定语言的实际效果之后，我们需要简要看一下这种语言的实现方式。有一个细节需要特别注意，这个语言是围绕 <a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a> 构建的。事实上，Byte Buddy 中，几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的，我们会在该类的文档中明确指出。如果你为 Byte Buddy 实现自定义功能，我们建议你遵守此原则。</p> </div> <div class="paragraph"> <p>作为所提到的不可变性的含义，例如配置 <code>ByteBuddy</code> 实例时，一定要小心。你也许会犯下面的错误：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">ByteBuddy byteBuddy = <span class="keyword">new</span> ByteBuddy();
byteBuddy.withNamingStrategy(<span class="keyword">new</span> NamingStrategy.SuffixingRandom(<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>));
DynamicType.Unloaded&lt;?&gt; dynamicType = byteBuddy.subclass(<span class="predefined-type">Object</span>.class).make();</code></pre> </div> </div> <div class="paragraph"> <p>你或许希望使用 <code>new NamingStrategy.SuffixingRandom("suffix")</code> 来自定义动态类型的命名策略。不是修改存储在 <code>byteBuddy</code> 变量中的实例，调用 <code>withNamingStrategy</code> 方法返回一个自定义的 <code>ByteBuddy</code> 实例，但是它却直接被丢弃了。结果，还是使用原来创建的默认配置来创建动态类型。</p> </div> </div> <div class="sect2"> <h3 id="redefining-and-rebasing-existing-classes">重新定义或者重定基底已经存在的类</h3> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <div class="paragraph"> <p><strong>D瓜哥注</strong></p> </div> <div class="paragraph"> <p><strong><code>type rebasing</code></strong> 不知如何翻译是好，暂且翻译为“<strong>重定基底</strong>”。下文中，根据语句通顺需要，偶尔也翻译成“<strong>重定义</strong>”。如果有好的翻译，欢迎给发PR。</p> </div> </td> </tr> </table> </div> <div class="paragraph"> <p>到目前为止，我们仅仅演示了如何使用 Byte Buddy 来创建已知类的子类。相同的 API 还可用于增强已有类。增加已有类有两种方式：</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">类型重定义（type redefinition）</dt> <dd> <p>当重定义一个类时，Byte Buddy 可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。如果使用其他的方法实现替换已经存在的方法实现，则原来存在的方法实现就会消失。例如，我们重定义下面这个类型</p> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Foo</span> {
  <span class="predefined-type">String</span> bar() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>; }
}</code></pre> </div> </div> <div class="paragraph"> <p>从 <code>bar</code> 方法返回 <code>"qux"</code>，那么该方法原来返回的 <code>"bar"</code> 等信息就会都被丢失掉。</p> </div> </dd> <dt class="hdlist1">类型重定基底（type rebasing）</dt> <dd> <p>当重定基底一个类时，Byte Buddy 保存基底类所有方法的实现。当 Byte Buddy 如执行类型重定义时，它将所有这些方法实现复制到具有兼容签名的重新命名的私有方法中，而不是抛弃重写的方法。这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法。通过这种方式，上述 <code>Foo</code> 类就会被重定义成下面这个样子：</p> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Foo</span> {
  <span class="predefined-type">String</span> bar() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> + bar<span class="error">$</span>original(); }
  <span class="directive">private</span> <span class="predefined-type">String</span> bar<span class="error">$</span>original() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>; }
}</code></pre> </div> </div> <div class="paragraph"> <p>原来返回 <code>bar</code> 的方法被保存到了另外一个方法里，因此还可以访问。当重定基底一个类时，Byte Buddy 对待所有方法定义就像你定义一个子类一样，例如，如果你想调用重定义方法的超类方法是，它会调用被重定义的方法。<em>相反，它最终将这个假设的超级类别变成了上面显示的重定义类型。</em></p> </div> </dd> </dl> </div> <div class="paragraph"> <p>任何重定基底、重定义或子类都是使用相同的 API 来执行，接口由 <code>DynamicType.Builder</code> 来定义。<em>这样，可以将类定义为子类，然后更改代码来替换重定类。</em>你只需要修改 Byte Buddy 领域特定语言的一个单词就能达到这个目的。这样，在定义的未来阶段，你就可以透明地切换任何一种方法：</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy().subclass(Foo.class)
<span class="keyword">new</span> ByteBuddy().redefine(Foo.class)
<span class="keyword">new</span> ByteBuddy().rebase(Foo.class)</code></pre> </div> </div> <div class="paragraph"> <p>这在本教程的其余部分都有所解释。因为定义子类对于 Java 开发人员来说是如此地熟悉，所以，接下来的所有解释以及 Byte Buddy 领域特定语言的实例都是用创建子类来演示。但是，请记住，所有类可以类似地通过重定义或重定基类来定义。</p> </div> </div> <div class="sect2"> <h3 id="loading-a-class">加载类</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Class</span>&lt;?&gt; type = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded();</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="reloading-a-class">重新加载类</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Foo</span> {
  <span class="predefined-type">String</span> m() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>; }
}

<span class="type">class</span> <span class="class">Bar</span> {
  <span class="predefined-type">String</span> m() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>; }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">ByteBuddyAgent.install();
Foo foo = <span class="keyword">new</span> Foo();
<span class="keyword">new</span> ByteBuddy()
  .redefine(Bar.class)
  .name(Foo.class.getName())
  .make()
  .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());
assertThat(foo.m(), is(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>));</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="working-with-unloaded-classes">操作没有加载的类</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;
<span class="type">class</span> <span class="class">Bar</span> { }</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyApplication</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    TypePool typePool = TypePool.Default.ofClassPath();
    <span class="keyword">new</span> ByteBuddy()
      .redefine(typePool.describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.Bar</span><span class="delimiter">&quot;</span></span>).resolve(), <span class="comment">// do not use 'Bar.class'</span>
                ClassFileLocator.ForClassLoader.ofClassPath())
      .defineField(<span class="string"><span class="delimiter">&quot;</span><span class="content">qux</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">String</span>.class) <span class="comment">// we learn more about defining fields later</span>
      .make()
      .load(<span class="predefined-type">ClassLoader</span>.getSystemClassLoader());
    assertThat(Bar.class.getDeclaredField(<span class="string"><span class="delimiter">&quot;</span><span class="content">qux</span><span class="delimiter">&quot;</span></span>), notNullValue());
  }
}</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="creating-java-agents">创建 Java Agents</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ToStringAgent</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> premain(<span class="predefined-type">String</span> arguments, <span class="predefined-type">Instrumentation</span> instrumentation) {
    <span class="keyword">new</span> AgentBuilder.Default()
        .type(isAnnotatedWith(ToString.class))
        .transform(<span class="keyword">new</span> AgentBuilder.Transformer() {
      <span class="annotation">@Override</span>
      <span class="directive">public</span> DynamicType.Builder transform(DynamicType.Builder builder,
                                              TypeDescription typeDescription,
                                              <span class="predefined-type">ClassLoader</span> classloader) {
        <span class="keyword">return</span> builder.method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>))
                      .intercept(FixedValue.value(<span class="string"><span class="delimiter">&quot;</span><span class="content">transformed</span><span class="delimiter">&quot;</span></span>));
      }
    }).installOn(instrumentation);
  }
}</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="loading-classes-in-android-applications">在 Android 应用中加载类</h3> </div> <div class="sect2"> <h3 id="working-with-generic-types">使用泛型类</h3> </div> </div> </div> <div class="sect1"> <h2 id="fields-and-methods">属性和方法</h2> <div class="sectionbody"> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> toString = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .name(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Type</span><span class="delimiter">&quot;</span></span>)
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance() <span class="comment">// Java reflection API</span>
  .toString();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> toString = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .name(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Type</span><span class="delimiter">&quot;</span></span>)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>)).intercept(FixedValue.value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World!</span><span class="delimiter">&quot;</span></span>))
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance()
  .toString();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>).and(returns(<span class="predefined-type">String</span>.class)).and(takesArguments(<span class="integer">0</span>))</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Foo</span> {
  <span class="directive">public</span> <span class="predefined-type">String</span> bar() { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
  <span class="directive">public</span> <span class="predefined-type">String</span> foo() { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
  <span class="directive">public</span> <span class="predefined-type">String</span> foo(<span class="predefined-type">Object</span> o) { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
}

Foo dynamicFoo = <span class="keyword">new</span> ByteBuddy()
  .subclass(Foo.class)
  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(<span class="string"><span class="delimiter">&quot;</span><span class="content">One!</span><span class="delimiter">&quot;</span></span>))
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>)).intercept(FixedValue.value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Two!</span><span class="delimiter">&quot;</span></span>))
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>).and(takesArguments(<span class="integer">1</span>))).intercept(FixedValue.value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Three!</span><span class="delimiter">&quot;</span></span>))
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance();</code></pre> </div> </div> <div class="sect2"> <h3 id="a-closer-look-at-fixed-values">深入细看一个固定值</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(Foo.class)
  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(<span class="integer">0</span>))
  .make();</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="delegating-a-method-call">委托方法调用</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Source</span> {
  <span class="directive">public</span> <span class="predefined-type">String</span> hello(<span class="predefined-type">String</span> name) { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
}

<span class="type">class</span> <span class="class">Target</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> hello(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + name + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>;
  }
}

<span class="predefined-type">String</span> helloWorld = <span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Source</span>.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>)).intercept(MethodDelegation.to(<span class="predefined-type">Target</span>.class))
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance()
  .hello(<span class="string"><span class="delimiter">&quot;</span><span class="content">World</span><span class="delimiter">&quot;</span></span>);</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Target</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> intercept(<span class="predefined-type">String</span> name) { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + name + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>; }
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> intercept(<span class="type">int</span> i) { <span class="keyword">return</span> <span class="predefined-type">Integer</span>.toString(i); }
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> intercept(<span class="predefined-type">Object</span> o) { <span class="keyword">return</span> o.toString(); }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> foo(<span class="predefined-type">Object</span> o1, <span class="predefined-type">Object</span> o2)</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> foo(<span class="annotation">@Argument</span>(<span class="integer">0</span>) <span class="predefined-type">Object</span> o1, <span class="annotation">@Argument</span>(<span class="integer">1</span>) <span class="predefined-type">Object</span> o2)</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MemoryDatabase</span> {
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; load(<span class="predefined-type">String</span> info) {
    <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.asList(info + <span class="string"><span class="delimiter">&quot;</span><span class="content">: foo</span><span class="delimiter">&quot;</span></span>, info + <span class="string"><span class="delimiter">&quot;</span><span class="content">: bar</span><span class="delimiter">&quot;</span></span>);
  }
}

<span class="type">class</span> <span class="class">LoggerInterceptor</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; log(<span class="annotation">@SuperCall</span> <span class="predefined-type">Callable</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt; zuper)
      <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Calling database</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">try</span> {
      <span class="keyword">return</span> zuper.call();
    } <span class="keyword">finally</span> {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned from database</span><span class="delimiter">&quot;</span></span>);
    }
  }
}

MemoryDatabase loggingDatabase = <span class="keyword">new</span> ByteBuddy()
  .subclass(MemoryDatabase.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">load</span><span class="delimiter">&quot;</span></span>)).intercept(MethodDelegation.to(LoggerInterceptor.class))
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LoggingMemoryDatabase</span> <span class="directive">extends</span> MemoryDatabase {

  <span class="directive">private</span> <span class="type">class</span> <span class="class">LoadMethodSuperCall</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> info;
    <span class="directive">private</span> LoadMethodSuperCall(<span class="predefined-type">String</span> info) {
      <span class="local-variable">this</span>.info = info;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Object</span> call() <span class="directive">throws</span> <span class="exception">Exception</span> {
      <span class="keyword">return</span> LoggingMemoryDatabase.super.load(info);
    }
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; load(<span class="predefined-type">String</span> info) {
    <span class="keyword">return</span> LoggerInterceptor.log(<span class="keyword">new</span> LoadMethodSuperCall(info));
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ChangingLoggerInterceptor</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; log(<span class="predefined-type">String</span> info, <span class="annotation">@Super</span> MemoryDatabase zuper) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Calling database</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">try</span> {
      <span class="keyword">return</span> zuper.load(info + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (logged access)</span><span class="delimiter">&quot;</span></span>);
    } <span class="keyword">finally</span> {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned from database</span><span class="delimiter">&quot;</span></span>);
    }
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Loop</span> {
  <span class="directive">public</span> <span class="predefined-type">String</span> loop(<span class="predefined-type">String</span> value) { <span class="keyword">return</span> value; }
  <span class="directive">public</span> <span class="type">int</span> loop(<span class="type">int</span> value) { <span class="keyword">return</span> value; }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Interceptor</span> {
  <span class="annotation">@RuntimeType</span>
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">Object</span> intercept(<span class="annotation">@RuntimeType</span> <span class="predefined-type">Object</span> value) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Invoked method with: </span><span class="delimiter">&quot;</span></span> + value);
    <span class="keyword">return</span> value;
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Forwarder</span>&lt;T, S&gt; {
  T to(S target);
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ForwardingLoggerInterceptor</span> {

  <span class="directive">private</span> <span class="directive">final</span> MemoryDatabase memoryDatabase; <span class="comment">// constructor omitted</span>

  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; log(<span class="annotation">@Pipe</span> Forwarder&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;, MemoryDatabase&gt; pipe) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Calling database</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">try</span> {
      <span class="keyword">return</span> pipe.to(memoryDatabase);
    } <span class="keyword">finally</span> {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned from database</span><span class="delimiter">&quot;</span></span>);
    }
  }
}

MemoryDatabase loggingDatabase = <span class="keyword">new</span> ByteBuddy()
  .subclass(MemoryDatabase.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">load</span><span class="delimiter">&quot;</span></span>)).intercept(MethodDelegation.withDefaultConfiguration()
    .withBinders(<span class="predefined-type">Pipe</span>.Binder.install(Forwarder.class)))
    .to(<span class="keyword">new</span> ForwardingLoggerInterceptor(<span class="keyword">new</span> MemoryDatabase()))
  .make()
  .load(getClass().getClassLoader())
  .getLoaded()
  .newInstance();</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="calling-a-super-method">调用超类方法</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .make()</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
  .make()</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="calling-a-default-method">调用默认方法</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">First</span> {
  <span class="keyword">default</span> <span class="predefined-type">String</span> qux() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">FOO</span><span class="delimiter">&quot;</span></span>; }
}

<span class="type">interface</span> <span class="class">Second</span> {
  <span class="keyword">default</span> <span class="predefined-type">String</span> qux() { <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">BAR</span><span class="delimiter">&quot;</span></span>; }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy(ClassFileVersion.JAVA_V8)
  .subclass(<span class="predefined-type">Object</span>.class)
  .implement(First.class)
  .implement(Second.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">qux</span><span class="delimiter">&quot;</span></span>)).intercept(DefaultMethodCall.prioritize(First.class))
  .make()</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="calling-a-specific-method">调用特定方法</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SampleClass</span> {
  <span class="directive">public</span> SampleClass(<span class="type">int</span> unusedValue) {
    <span class="local-variable">super</span>();
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
  .defineConstructor(<span class="predefined-type">Arrays</span>.&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt;asList(<span class="type">int</span>.class), <span class="predefined-type">Visibility</span>.PUBLIC)
  .intercept(MethodCall.invoke(<span class="predefined-type">Object</span>.class.getDeclaredConstructor()))
  .make()</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="accessing-fields">访问属性</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">UserType</span> {
  <span class="directive">public</span> <span class="predefined-type">String</span> doSomething() { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
}

<span class="type">interface</span> <span class="class">Interceptor</span> {
  <span class="predefined-type">String</span> doSomethingElse();
}

<span class="type">interface</span> <span class="class">InterceptionAccessor</span> {
  Interceptor getInterceptor();
  <span class="type">void</span> setInterceptor(Interceptor interceptor);
}

<span class="type">interface</span> <span class="class">InstanceCreator</span> {
  <span class="predefined-type">Object</span> makeInstance();
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> UserType&gt; dynamicUserType = <span class="keyword">new</span> ByteBuddy()
  .subclass(UserType.class)
    .method(not(isDeclaredBy(<span class="predefined-type">Object</span>.class)))
    .intercept(MethodDelegation.toField(<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptor</span><span class="delimiter">&quot;</span></span>))
  .defineField(<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptor</span><span class="delimiter">&quot;</span></span>, Interceptor.class, <span class="predefined-type">Visibility</span>.PRIVATE)
  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty())
  .make()
  .load(getClass().getClassLoader())
  .getLoaded();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">InstanceCreator factory = <span class="keyword">new</span> ByteBuddy()
  .subclass(InstanceCreator.class)
    .method(not(isDeclaredBy(<span class="predefined-type">Object</span>.class)))
    .intercept(MethodDelegation.construct(dynamicUserType))
  .make()
  .load(dynamicUserType.getClassLoader())
  .getLoaded().newInstance();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">HelloWorldInterceptor</span> <span class="directive">implements</span> Interceptor {
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">String</span> doSomethingElse() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World!</span><span class="delimiter">&quot;</span></span>;
  }
}

UserType userType = (UserType) factory.makeInstance();
((InterceptionAccessor) userType).setInterceptor(<span class="keyword">new</span> HelloWorldInterceptor());</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="miscellaneous">杂项</h3> </div> </div> </div> <div class="sect1"> <h2 id="annotations">注解</h2> <div class="sectionbody"> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@interface</span> RuntimeDefinition { }

<span class="type">class</span> <span class="class">RuntimeDefinitionImpl</span> <span class="directive">implements</span> RuntimeDefinition {
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType() {
    <span class="keyword">return</span> RuntimeDefinition.class;
  }
}

<span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .annotateType(<span class="keyword">new</span> RuntimeDefinitionImpl())
  .make();</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
    .annotateType(<span class="keyword">new</span> RuntimeDefinitionImpl())
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>))
    .intercept(SuperMethodCall.INSTANCE)
    .annotateMethod(<span class="keyword">new</span> RuntimeDefinitionImpl())
  .defineField(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Object</span>.class)
    .annotateField(<span class="keyword">new</span> RuntimeDefinitionImpl())</code></pre> </div> </div> <div class="sect2"> <h3 id="type-annotations">类型注解</h3> <div class="paragraph"> <p>Byte Buddy 暴露并编写了类型注解，它们被引入到 Java 8，并成为其中的一部分。</p> </div> </div> <div class="sect2"> <h3 id="attribute-appenders">属性附加器</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">AnnotatedMethod</span> {
  <span class="annotation">@SomeAnnotation</span>
  <span class="type">void</span> bar() { }
}
<span class="keyword">new</span> ByteBuddy()
  .subclass(AnnotatedMethod.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>))
  .intercept(StubMethod.INSTANCE)
  .attribute(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE)</code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="custom-instrumentation">定制化仪表</h2> <div class="sectionbody"> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">LDC     <span class="integer">10</span>  <span class="comment">// stack contains 10</span>
LDC     <span class="integer">50</span>  <span class="comment">// stack contains 10, 50</span>
IADD        <span class="comment">// stack contains 60</span>
IRETURN     <span class="comment">// stack is empty</span></code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="integer">12</span> <span class="octal">00</span> <span class="octal">01</span>
<span class="integer">12</span> <span class="octal">00</span> <span class="octal">02</span>
<span class="integer">60</span>
AC</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">enum</span> IntegerSum <span class="directive">implements</span> StackManipulation {

  INSTANCE; <span class="comment">// singleton</span>

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">boolean</span> isValid() {
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> Size apply(MethodVisitor methodVisitor,
                    Implementation.Context implementationContext) {
    methodVisitor.visitInsn(Opcodes.IADD);
    <span class="keyword">return</span> <span class="keyword">new</span> Size(-<span class="integer">1</span>, <span class="integer">0</span>);
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">enum</span> SumMethod <span class="directive">implements</span> ByteCodeAppender {

  INSTANCE; <span class="comment">// singleton</span>

  <span class="annotation">@Override</span>
  <span class="directive">public</span> Size apply(MethodVisitor methodVisitor,
                    Implementation.Context implementationContext,
                    MethodDescription instrumentedMethod) {
    <span class="keyword">if</span> (!instrumentedMethod.getReturnType().asErasure().represents(<span class="type">int</span>.class)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(instrumentedMethod + <span class="string"><span class="delimiter">&quot;</span><span class="content"> must return int</span><span class="delimiter">&quot;</span></span>);
    }
    StackManipulation.Size operandStackSize = <span class="keyword">new</span> StackManipulation.Compound(
      IntegerConstant.forValue(<span class="integer">10</span>),
      IntegerConstant.forValue(<span class="integer">50</span>),
      IntegerSum.INSTANCE,
      MethodReturn.INTEGER
    ).apply(methodVisitor, implementationContext);
    <span class="keyword">return</span> <span class="keyword">new</span> Size(operandStackSize.getMaximalSize(),
                    instrumentedMethod.getStackSize());
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">enum</span> SumImplementation <span class="directive">implements</span> Implementation {

  INSTANCE; <span class="comment">// singleton</span>

  <span class="annotation">@Override</span>
  <span class="directive">public</span> InstrumentedType prepare(InstrumentedType instrumentedType) {
    <span class="keyword">return</span> instrumentedType;
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> ByteCodeAppender appender(<span class="predefined-type">Target</span> implementationTarget) {
    <span class="keyword">return</span> SumMethod.INSTANCE;
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">SumExample</span> {
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">int</span> calculate();
}

<span class="keyword">new</span> ByteBuddy()
  .subclass(SumExample.class)
    .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">calculate</span><span class="delimiter">&quot;</span></span>))
    .intercept(SumImplementation.INSTANCE)
  .make()</code></pre> </div> </div> <div class="sect2"> <h3 id="creating-a-custom-assigner">创建自定义分配器</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">enum</span> ToStringAssigner <span class="directive">implements</span> Assigner {

  INSTANCE; <span class="comment">// singleton</span>

  <span class="annotation">@Override</span>
  <span class="directive">public</span> StackManipulation assign(TypeDescription.Generic source,
                                  TypeDescription.Generic target,
                                  Assigner.Typing typing) {
    <span class="keyword">if</span> (!source.isPrimitive() &amp;&amp; target.represents(<span class="predefined-type">String</span>.class)) {
      MethodDescription toStringMethod = <span class="keyword">new</span> TypeDescription.ForLoadedType(<span class="predefined-type">Object</span>.class)
        .getDeclaredMethods()
        .filter(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>))
        .getOnly();
      <span class="keyword">return</span> MethodInvocation.invoke(toStringMethod).virtual(sourceType);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> StackManipulation.Illegal.INSTANCE;
    }
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>))
    .intercept(FixedValue.value(<span class="integer">42</span>)
      .withAssigner(<span class="keyword">new</span> PrimitiveTypeAwareAssigner(ToStringAssigner.INSTANCE),
                    Assigner.Typing.STATIC))
  .make()</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="creating-a-custom-parameter-binder">创建自定义参数绑定器</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@interface</span> StringValue {
  <span class="predefined-type">String</span> value();
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">enum</span> StringValueBinder
    <span class="directive">implements</span> TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;StringValue&gt; {

  INSTANCE; <span class="comment">// singleton</span>

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;StringValue&gt; getHandledType() {
    <span class="keyword">return</span> StringValue.class;
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> MethodDelegationBinder.ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loaded&lt;StringValue&gt; annotation,
                                                         MethodDescription source,
                                                         ParameterDescription target,
                                                         Implementation.Target implementationTarget,
                                                         Assigner assigner,
                                                         Assigner.Typing typing) {
    <span class="keyword">if</span> (!target.getType().asErasure().represents(<span class="predefined-type">String</span>.class)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(target + <span class="string"><span class="delimiter">&quot;</span><span class="content"> makes illegal use of @StringValue</span><span class="delimiter">&quot;</span></span>);
    }
    StackManipulation constant = <span class="keyword">new</span> TextConstant(annotation.loadSilent().value());
    <span class="keyword">return</span> <span class="keyword">new</span> MethodDelegationBinder.ParameterBinding.Anonymous(constant);
  }
}</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ToStringInterceptor</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> makeString(<span class="annotation">@StringValue</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello!</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> value) {
    <span class="keyword">return</span> value;
  }
}

<span class="keyword">new</span> ByteBuddy()
  .subclass(<span class="predefined-type">Object</span>.class)
  .method(named(<span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>))
    .intercept(MethodDelegation.withDefaultConfiguration()
      .withBinders(StringValueBinder.INSTANCE)
      .to(ToStringInterceptor.class))
  .make()</code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="license">附录 A: 版权声明</h2> <div class="sectionbody"> <pre>
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</pre> </div> </div> </div> <div id="footer"> <div id="footer-text"> V 0.1.0<br> 最后更新时间 2017-08-04 19:25:05 CST </div> </div> 